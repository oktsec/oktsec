package commands

import (
	"fmt"
	"os"
	"strings"

	"github.com/oktsec/oktsec/internal/discover"
	"github.com/oktsec/oktsec/internal/identity"
	"gopkg.in/yaml.v3"

	"github.com/spf13/cobra"
)

func newInitCmd() *cobra.Command {
	var keysDir, configOut string

	cmd := &cobra.Command{
		Use:   "init",
		Short: "Generate oktsec config and keypairs from discovered MCP servers",
		Example: `  oktsec init
  oktsec init --keys ./keys --config ./oktsec.yaml`,
		RunE: func(cmd *cobra.Command, args []string) error {
			result, err := discover.Scan()
			if err != nil {
				return err
			}

			if result.TotalServers() == 0 {
				fmt.Println("No MCP servers found. Run 'oktsec discover' to check.")
				return nil
			}

			// Create keys directory
			if err := os.MkdirAll(keysDir, 0o700); err != nil {
				return fmt.Errorf("creating keys directory: %w", err)
			}

			// Build config
			type agentYAML struct {
				CanMessage []string `yaml:"can_message,flow"`
				Source     string   `yaml:"source"`
				RiskLevel  string   `yaml:"risk_level"`
			}

			agents := make(map[string]agentYAML)
			var generated []string

			for _, entry := range result.AllServers() {
				name := entry.Server.Name
				risk := assessRisk(entry.Server)

				agents[name] = agentYAML{
					CanMessage: []string{"*"},
					Source:     entry.Client,
					RiskLevel:  risk,
				}

				// Generate keypair
				kp, err := identity.GenerateKeypair(name)
				if err != nil {
					return fmt.Errorf("generating keypair for %s: %w", name, err)
				}
				if err := kp.Save(keysDir); err != nil {
					return fmt.Errorf("saving keypair for %s: %w", name, err)
				}
				generated = append(generated, name)
			}

			// Write config YAML
			cfg := map[string]any{
				"version": "1",
				"server": map[string]any{
					"port":      8080,
					"log_level": "info",
				},
				"identity": map[string]any{
					"keys_dir":          keysDir,
					"require_signature": false,
				},
				"agents": agents,
			}

			data, err := yaml.Marshal(cfg)
			if err != nil {
				return fmt.Errorf("marshaling config: %w", err)
			}

			header := "# Generated by oktsec init â€” observe mode (audit-only, no blocking)\n"
			if err := os.WriteFile(configOut, append([]byte(header), data...), 0o644); err != nil {
				return fmt.Errorf("writing config: %w", err)
			}

			// Print summary
			fmt.Println("Generated:")
			fmt.Printf("  %-24s # Policy config (observe mode)\n", configOut)
			fmt.Printf("  %-24s # Identity keypairs\n", keysDir+"/")
			fmt.Println()
			fmt.Println("Configuration preview:")
			fmt.Println()
			fmt.Println("  mode: observe              # Log everything, block nothing")
			fmt.Println("  require_signature: false   # Identity off until you activate it")
			fmt.Println()
			fmt.Println("  agents:")
			for _, entry := range result.AllServers() {
				name := entry.Server.Name
				risk := assessRisk(entry.Server)
				fmt.Printf("    %-20s source: %-16s risk: %s\n", name, entry.Client, strings.ToUpper(risk))
			}
			fmt.Println()
			fmt.Printf("  Keypairs generated for %d agents in %s/\n", len(generated), keysDir)
			fmt.Println()
			fmt.Println("Ready to observe. Run 'oktsec wrap <client>' to start.")

			return nil
		},
	}

	cmd.Flags().StringVar(&keysDir, "keys", "./keys", "directory for generated keypairs")
	cmd.Flags().StringVar(&configOut, "config", "oktsec.yaml", "output config file path")
	return cmd
}

// assessRisk assigns a risk level based on the MCP server's name, command, and arguments.
func assessRisk(srv discover.MCPServer) string {
	cmdLine := strings.ToLower(srv.Name + " " + srv.Command + " " + strings.Join(srv.Args, " "))

	switch {
	case containsAny(cmdLine, "database", "postgres", "mysql", "sqlite", "mongo", "redis", "sql"):
		return "critical"
	case containsAny(cmdLine, "filesystem", "file", "fs", "directory"):
		return "high"
	case containsAny(cmdLine, "github", "git", "gitlab"):
		return "high"
	case containsAny(cmdLine, "slack", "discord", "email", "message", "notification"):
		return "medium"
	case containsAny(cmdLine, "browser", "puppeteer", "playwright", "fetch", "http"):
		return "high"
	default:
		return "unknown"
	}
}

func containsAny(s string, substrs ...string) bool {
	for _, sub := range substrs {
		if strings.Contains(s, sub) {
			return true
		}
	}
	return false
}
